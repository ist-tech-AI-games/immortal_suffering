// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

struct ColorMapEntry {
    int ID; float4 Color;
};

RWStructuredBuffer<int> Result;
RWTexture2D<float4> DebugTex;  // Must have Width * Height size;
Texture2D<float4> SourceTex;
// SamplerState samplerSourceTex;
SamplerState my_clamp_point_sampler;

static const int COLORMAXCOUNT = 16;
int ColorCount;
// int ColorIDs[COLORMAXCOUNT];
int FallbackColorID = -1;
float CompareThreshold = 0.2;
float AlphaThreshold = 0.5;
// float4 ColorValues[COLORMAXCOUNT];
float4 FallBackColor = float4(0, 0, 0, 0);

StructuredBuffer<ColorMapEntry> ColorMap;

int Width; int Height;

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    uint srcW, srcH;
    SourceTex.GetDimensions(srcW, srcH);

    if (id.x >= srcW || id.y >= srcH) return;

    float2 uv = (id.xy + 0.5) / float2(srcW, srcH);
    float4 color = SourceTex.SampleLevel(my_clamp_point_sampler, uv, 0);

    uint2 resultInd = uv * float2(Width, Height) - 0.5;

    int colorId = FallbackColorID;
    for (int i = 0; i < ColorCount; i++)
    {
        float3 diff = color.xyz - ColorMap[i].Color.xyz;
        if (color.w >= AlphaThreshold && dot(diff, diff) < CompareThreshold)
        {
            colorId = ColorMap[i].ID;
            break;
        }
    }

    Result[(Height - resultInd.y) * Width + resultInd.x] = colorId;

    // ----- debug -----

    float4 matchedColor = FallBackColor;
    for (int j = 0; j < ColorCount; j++)
    {
        if (ColorMap[j].ID == colorId)
        {
            matchedColor = ColorMap[j].Color;
            break;
        }
    }

    DebugTex[resultInd] = matchedColor;
}
