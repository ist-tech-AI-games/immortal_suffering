// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

struct ColorMapEntry {
    int ID; float3 _Padding; float4 Color;
};

RWStructuredBuffer<int> Result;
RWTexture2D<float4> DebugTex;  // Must have Width * Height size;
Texture2D<float4> SourceTex;

static const int COLORMAXCOUNT = 16;
int ColorCount;
int FallbackColorID = -1;
float CompareThreshold = 0.2;
float AlphaThreshold = 0.5;
float4 FallBackColor = float4(0, 0, 0, 0);

StructuredBuffer<ColorMapEntry> ColorMap;
// RWStructuredBuffer<float4> DebugColorMap;
// RWStructuredBuffer<float4> DebugFloatArray;

uint Width, Height;

float3 gammaToLinear(float3 input)
{
    return input < 0.04045 ? input * (1.0 / 12.92) : pow((input + 0.055) * (1.0 / (1.0 + 0.055)), 2.4);
}

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    uint srcW, srcH;
    SourceTex.GetDimensions(srcW, srcH);

    if (id.x >= Width || id.y >= Height) return;

    float2 uv = (id.xy + 0.5) / float2(Width, Height);
    uint2 srcInd = uv * float2(srcW, srcH);
    float4 color = SourceTex[srcInd.xy]; // SourceTex.SampleLevel(my_clamp_point_sampler, uv, 0);

    int colorId = FallbackColorID;
    for (int i = 0; i < ColorCount; i++)
    {
        float3 diff = color.xyz - gammaToLinear(ColorMap[i].Color.xyz);
        if (color.w >= AlphaThreshold && dot(diff, diff) < CompareThreshold)
        {
            colorId = ColorMap[i].ID;
            // if (colorId == 3)
            // {
            //     DebugFloatArray[0].xyz = color.xyz;
            //     DebugFloatArray[1].xyz = ColorMap[i].Color.xyz;
            //     DebugFloatArray[2].x = dot(diff, diff);
            //     DebugFloatArray[3].xy = uv;
            // }
            break;
        }
    }

    Result[(Height - id.y) * Width + id.x] = colorId;

    // ----- debug -----

    float4 matchedColor = FallBackColor;
    for (int j = 0; j < ColorCount; j++)
    {
        if (ColorMap[j].ID == colorId)
        {
            matchedColor.xyz = gammaToLinear(ColorMap[j].Color.xyz);
            matchedColor.w = ColorMap[j].Color.w;
            break;
        }
    }

    // for (int k = 0; k < ColorCount; k++)
    // {
    //     DebugColorMap[k] = ColorMap[k].Color;
    // }

    DebugTex[id.xy] = matchedColor;
}
